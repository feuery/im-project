(ns merpg.2D.core
  (:require [seesaw.core :as seesaw]
            [clojure.string :as s]
            [newui.listen :refer :all]
;            [newui.ui :refer [maximize!]]
            [merpg.utils :refer :all]
            [clojure.java.io :refer [file]])
  (:import  [java.awt Color]
            [java.awt.event KeyEvent]
            [java.awt.image BufferedImage]
            [javax.imageio ImageIO]))

;(defn full-screen!! [f]
;  (if-let [f  (maximize! f)]
;    (.setUndecorated true)
;    (println "Error")))

;;;;;; (def ^:dynamic *draw-queue* (atom nil)) ;Frames are used as keys...
(def ^:dynamic *buffer*  nil)
(def ^:dynamic *current-color* Color/WHITE)
(def ^:dynamic key-up? "Fn's to read the keyboard state will be bound to these vars when inside drawqueue-fns or update-fn." nil)
(def ^:dynamic key-down? "Fn's to read the keyboard state will be bound to these vars when inside drawqueue-fns or update-fn." nil)

(defprotocol IObject2
  (set-angle [this angle])
  (Location [this])
  (Location! [this [x y]])
  (Dimensions [this])
  (move [this how-much]))

(defmacro with-handle
  "Brings a handle-var, which is (.getGraphics *buffer*), into the containing forms. Also handles setting the *current-color*."
  [& forms]
  `(try
     (let [~'handle (.getGraphics *buffer*)
           old-color# (.getColor ~'handle)]
       (try
         (cond
          (= java.awt.Color (class *current-color*))
          (.setColor ~'handle *current-color*)
          (string? *current-color*)
          (.setColor ~'handle (Color/decode *current-color*))
          :t
          (throw (Exception. (str "*current-color* = " *current-color*))))
         ~@forms
         (finally
           (.setColor ~'handle old-color#))))
     (catch NullPointerException ex#
       (println "*buffer* " (if-not (nil? *buffer*) "not" " nil"))
       (println "*color* " (if-not (nil? *current-color*) "not") " nil"))))

(defmacro draw-to-surface [surface & forms]
  `(binding [*buffer* ~surface]
    ~@forms))

(defmacro with-color [color & other-forms]
    `(binding [*current-color* ~color]
       ~@other-forms))

(defmacro def-primitive-draw
  "Defines a function to do both Drawing and Filling a primitive shape. You have to define the exact procedures of doing these.

Introduces following bindings into the namespace:
x      - x-component of the location where to draw the primitive
y      - y-component of the location where to draw the primitive
width  - desired with of the primitive
height - desired height of the primitive
fill?  - to fill the primitive or to not? You shouldn't need this parameter when writing the function, but this is essential for callers.

handle - The Graphics handle to which you draw stuff

Example implementation of Rect: (def-primitive-draw Rect  :doc-string \"Here be dragons\"   :fill (.fillRect handle x y width height) :draw (.drawRect handle x y width height))"

  [name & {:keys [doc-string] :or {doc-string ""}}]
  (let [fill-name (symbol (str ".fill" (s/capitalize name)))
        draw-name (symbol (str ".draw" (s/capitalize name)))]
    `(defn ~name
       ~doc-string
       [~'x ~'y ~'width ~'height & {:keys [~'fill?] :or {~'fill? false}}]
       (with-handle
         (if ~'fill?
           (~fill-name ~'handle ~'x ~'y ~'width ~'height)
           (~draw-name ~'handle ~'x ~'y ~'width ~'height))))))

(def-primitive-draw Rect)

(def-primitive-draw Oval)

;(defn Rect [x y width height & {:keys [fill?] :or {fill? false}}]
;  (with-handle
;    (if fill?
;      (.fillRect handle x y width height)
;      (.drawRect handle x y width height))))
   

(defn Line
  ([[x1 y1][x2 y2]]
     (with-handle
       (.drawLine handle x1 y1 x2 y2)))
  ([x1 y1 x2 y2]
     (Line [x1 y1] [x2 y2])))
  

(defprotocol Drawable
  (Draw [this])
  (do-Draw [this[x y]]))

(extend-type java.lang.String
  Drawable
  (do-Draw [this [x y]]
    (with-handle
      (.drawString handle this x y)))
  (Draw [this]
    (with-handle 
      (.drawString handle this 0 0))))

(extend-type BufferedImage
  Drawable
  (Draw [this]
    (with-handle
      (.drawImage handle this 0 0 nil)))
  (do-Draw [this [x y]]
    (with-handle
      (.drawImage handle this x y nil))))

(defrecord merpg-object [x y img Angle visible?]
  Drawable
  (Draw [this]
    (do-Draw img [x y]))

  (do-Draw [this [x y]]
    (println "Drawing at [" x ", " y "]")
    (if visible?
      (do-Draw img [x y])
      this))

  IObject2
;  (angle [_] Angle)
  (set-angle [this angl]
    (assoc this :Angle angl))
  
  (Location [_] {:x x :y y})
  (Location! [this [X Y]]
    (-> this
        (assoc :x (int X))
        (assoc :y (int Y))))
  (Dimensions [_] [(.getWidth img) (.getHeight img)])
  (move [this how-much]
    (let [{x :x y :y} (Location this)]
      (Location! this [(+ x (* how-much (cos (:Angle this))))
                       (+ y (* how-much (sin (:Angle this))))])))) ;; Ja sit jos tulot lisättäisiin vanhaan sijaintiin, eikä asetettaisi niitä suoraan uudeksi sijainniksi?

(defn merpg-object? [obj]
  (instance? merpg.2D.core.merpg-object obj))

(defn image
  ([path]
     (ImageIO/read (file path)))
  ([width height]
     (BufferedImage. width height BufferedImage/TYPE_INT_ARGB)))

(defn object [path-or-img & {:keys [x y angle visible?] :or {x 0 y 0 angle 0 visible? true}}]
  {:pre [(<= 0 x 360)]}
  
  (merpg-object. x y (if (string? path-or-img)
                       (image path-or-img)
                       path-or-img) angle visible?))

(defn width
  ([surface]
     {:pre [(instance? java.awt.Image surface)]} 
     (.getWidth surface))
  ([]
       (width *buffer*)))

(defn height
  ([surface]
     {:pre [(instance? java.awt.Image surface)]}
     (.getHeight surface))
  ([]
     (height *buffer*)))
     
     
(defn make-game [objects & {:keys [window-width window-height title
                                   pre-drawqueue
                                   post-drawqueue
                                   update] :or {window-width 800 window-height 600 title "Testi"
                                                pre-drawqueue #()
                                                post-drawqueue #()
                                                update (fn [state] state)}}]
  (let [view (image window-width window-height)
        state (atom objects)

        valid-keys [KeyEvent/VK_UP KeyEvent/VK_DOWN KeyEvent/VK_LEFT KeyEvent/VK_RIGHT KeyEvent/VK_CONTROL KeyEvent/VK_SHIFT KeyEvent/VK_ESCAPE]
        valid-codes [ :up :down :left :right :ctrl :shift :esc]
        keyboard-state (atom (zipmap valid-codes (repeat (count valid-codes) false)))

        keycode-to-keyword (fn [keycode]
                             (cond
                              (= keycode KeyEvent/VK_UP) :up
                              (= keycode KeyEvent/VK_DOWN) :down
                              (= keycode KeyEvent/VK_LEFT) :left
                              (= keycode KeyEvent/VK_RIGHT) :right
                              (= keycode KeyEvent/VK_CONTROL) :ctrl
                              (= keycode KeyEvent/VK_SHIFT) :shift
                              (= keycode KeyEvent/VK_ESCAPE) :esc
                              :t (throw (Exception. (str "Keylistener failed with KeyCode " keycode)))))

        create-keylistener (fn [retval e]
                             (fn [state]
                               (if (in? valid-keys (.getKeyCode e))
                                 (assoc state (keycode-to-keyword (.getKeyCode e)) retval)
                                 state)))
        
        f (-> (seesaw/frame
               :width window-width
               :height window-height
               :on-close :dispose
               :title title)
              (Listen :key-pressed (fn [e]
                                     (swap! keyboard-state (create-keylistener true e))))
              (Listen :key-released (fn [e]
                                      (swap! keyboard-state (create-keylistener false e)))))
        viewport  (seesaw/canvas
                   :paint (fn [jee g]
                            (.setColor g Color/BLACK)
                            (try
                              
                              (.drawImage g view 0 0 nil)
                              (catch IllegalArgumentException ex
                                (println "Viewport hajosi!")
                                (throw ex)))))
        render-loop (doto
                        (Thread.
                         (fn []
                           (binding [*buffer* view
                                     key-down? (fn [key]
                                                (key @keyboard-state))
                                     key-up? (complement key-down?)]
                             (println "Rendering started")
                             (Thread/sleep 600)
                             (try
                             (loop []
                               (Rect 0 0 (width) (height) :fill? true)
                               (pre-drawqueue)
                               
                               (let [*draw-queue* (->> @state
                                                       (filter map-entry?)
                                                       (map #(nth % 1))
                                                       (filter merpg-object?))]
                                 
                                 (doseq [to-draw *draw-queue*]
                                   ;; Now we can init state to the objects-map without damning the rendering process
                                   (try
                                     (Draw (if (map-entry? to-draw)
                                             (nth to-draw 1)
                                             to-draw))
                                     (catch IllegalArgumentException ex
                                       (println "Nyt kusee dispatching...")
                                       (println (class to-draw))
                                       (throw ex))
                                     (catch Exception ex
                                       (println "Rendering failed")
                                       (throw ex)))))

                               (post-drawqueue)
                               
                               (.repaint viewport)
                               (Thread/sleep 10)
                               (when (.isVisible f)
                                 (recur)))
                             (catch UnsupportedOperationException ex
                               (println "Joku tekee tyhmiä juttuja boolille tässä säikeessä")
                               (println ex))))))
                      (.start))
        update-loop (doto
                        (Thread.
                         (fn []
                           (binding [key-down? (fn [key]
                                                (key @keyboard-state))
                                     key-up? (complement key-down?)]
                           (loop []

                             (swap! state update)
                               
                             (Thread/sleep 100)
                             (when (.isVisible f)
                               (recur))))))
                      (.start))]
    (seesaw/config! f :content viewport)
    (seesaw/show! f)))

(defn Tiia-testikoodi []
  (let [loc (atom {:x 0 :y 0 :Angle 0 })]
    (make-game {:tiia (object "./Tiia.png" :x 50 :y 100 :angle 45)}
               :update (fn [{tiia :tiia}]
                         (let [{x :x
                                kulma :Angle
                                y :y} tiia]
                           (swap! loc #(-> %
                                           (assoc :x x)
                                           (assoc :y y)
                                           (assoc :Angle kulma)))
                           (let [tiia (if (key-down? :up)
                                        (move tiia 10)
                                        tiia)]
                             {:tiia (if (key-down? :right)
                                      (set-angle tiia (+ 10 (:Angle tiia)))
                                      (if (key-down? :left)
                                        (set-angle tiia (- (:Angle tiia) 10))
                                        tiia))})))
               :post-drawqueue
               #(with-color "#0000FF"
                  (let [x (/ (width) 2)
                        y (/ (height) 2)]
                    
                    (do-Draw "Hello world!" [x y])
                    (let [{äxä :x yxy :y angle :Angle w :w h :h} @loc]
                      (do-Draw (str "Location: " äxä ", " yxy "    - Angle: " angle ) [480 50])                             
                      (with-color "#00FF00"
                        (let [x2 (+ äxä (* (cos angle) 70))
                              y2 (+ yxy (* (sin angle) 70))]
                          (Line äxä yxy x2 y2)
                          (with-color "#FF0000"
                            (Oval (- x2 (/ 50 2)) (- y2 (/ 50 2)) 50 50 :fill? true)))))
                    
                    (with-color "#000000"
                      (do-Draw (str "Is up pressed? " (key-down? :up)) [50 50])
                      (do-Draw (str "Is down pressed? " (key-down? :down)) [50 60])
                      (do-Draw (str "Is right pressed? " (key-down? :right)) [50 70])
                      (do-Draw (str "Is left pressed? " (key-down? :left)) [50 80])
                      (do-Draw (str "Is ctrl pressed? " (key-down? :ctrl)) [50 90])
                      (do-Draw (str "Is shift? " (key-down? :shift)) [50 100])
                      (do-Draw (str "Is esc? " (key-down? :esc)) [50 110])))))))
